1、hashmap总结

- 每一个键值对是使用链表节点保存的
- 非线程安全
- 内部使用数组来保存数据，每个数组元素保存了节点的地址

- 存储的时候使用key生成的hash值对数组长度取余，得到要存储到数组中的索引位置
- 如果有多个key计算的数组索引位置相同，就链接到对应索引位置链表节点的后面，也成为哈希冲突
  - 当冲突个数大于8时，链接结构改为红黑树结构，因为红黑树的插入、遍历、删除的时间复杂度都为O(logn)，可以提高对应效率
- 遍历map不保证存入顺序
- 当数组元素大于阈值（长度的75%）时会触发2倍的扩容，扩容会对数组中的元素进行重新排列
  - 原数组元素对应的只有一个节点，那么重新按照hash对新的数组长度取余计算新的位置
  - 原数组元素对应了多个节点，遍历链表节点，如果有hash值对新长度取余不等于原索引位置的节点放到新的位置上

2、二叉树

- BFS使用队列
- DFS使用递归或者栈

3、堆

- 分为小顶堆和大顶堆
- 在java中实现的类名为PriorityQueue，默认为小顶堆（元素类本身实现了comparator接口），可以在构造函数中传入比较器指定比较规则。
- 插入、删除时间复杂度为O(logn)，获取最大值/最小值的为O(1)
- 常用来解决top k 问题，也可以用来实现排序

